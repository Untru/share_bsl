# Мастер-класс: Создание Telegram-бота для декомпиляции 1С файлов на OneScript и Осень

## Введение

Приветствую всех! Меня зовуит Чегодаев Павел, и я хочу вместе с вами пройти мастер класс по разработке бота на OneScript и фреймворка Осень.
На написание этой статьи, меня вдохновила эта публикация [Мастер класс по созданию приложения](https://infostart.ru/1c/articles/2275659/). Так как вторая пока еще не вышло я возьму на себя смелость продолжить начинания Владимира. 

## Почему Осень?
Есть желание расширять кругозор после 15 лет 1С. В Осени многие концепции заимствованы из [Java](https://infostart.ru/1c/articles/1980026/) — это стало отличным поводом изучить новые подходы, оставаясь в знакомой среде языка 1с.

Так как статья про мониторинг возможно когда нибудь выйдет, я предлагаю взять другую тему.

## Техническое задание

Написать бот для телеграмм который на вход должен принимать бинарные файлы, а на выходе возвращать исходный код.
Приложение можно развернуть в контейнере

Чтение кода должно быть реализованно максимально удобно.

## Архитектура
Любая разработка начинается с архитектуры решения. Давайте обознчим основную функциональность которая должна быть

+ Обработка сообщений в боте
+ Разбор файлов на исходники
+ Публикация исходников

Попробуйте нарисовать диаграмму классов, а потом сравним, что у нас получается.

Как мы все знаем, лучший код писался во времена УТ 10 с километровыми методами которые делали сразу все. Но мы назло всем так делать не будем. Паттернов и подходов к разработке приложений много, но давайте возьмем за основу **MVC**.

Попробуем разделить наше приложение на слои, чтобы они были независимы.

**Что такое MVC:**
- **V (View)** — так как у нас Telegram-бот, то за вид пусть он и отвечает.
- **C (Controller)** — это наш мостик между отображением и бизнес-логикой.
- **M (Model)** — тут работа с БД и бизнес-логика.

У меня получилось так:

![alt text](https://img.plantuml.biz/plantuml/svg/bLBBIiD05DtFLynI5_q15r9mxKU4DhXmsaWILree5GH1A4ANfG_n0nersZOn_OLp_yWpqsAZD10Nmp3tddlEkVTECugzCBxk6DKoNXJfiw0RXu4nVhWBd0TjtwWhhtNfNVYbjBvHMcyXU48X0pmZHSRp9dqia2DNLGbzeZ7bey0hKjvB6SWZvdmNIEI1q2_6XaV7gaUH7t5dfQmxTiWKx_XmF5EvGqAf9TPOo3tlrHuy8d1DWHmR9Z8PqbaX_JtWT_KssQlkeT6uFQrdeGveHrTbyXyKXzgeuhMBcB6VJpju6x0LNCKBOojaNC0XEbirmQQKi8jqbRQYZbN7aBXP9cw-VtLLq--sxRVy1W00
)

Для удобства я буду диаграммы также оставлься с исходном виде

```pluntuml
@startuml
class Controller
class Model
package Controller {
  class БотТелеграмм
БотТелеграмм : ПроверитьСообщения()
}
  
package Model {
  class МенеджерПубликаций
  class Декомпилятор
  class Публикатор
}
БотТелеграмм --|> МенеджерПубликаций
МенеджерПубликаций --|> Декомпилятор
МенеджерПубликаций --|> Публикатор
Декомпилятор : РазоборатьФайл()
Публикатор : Опубликовать()
МенеджерПубликаций : ОбработатьФайл()

@enduml
```
Давайте создавать проект. Что бы я не делал, я начинаю его с команды git init это мне позволит в последстии версионировать код и может даже чем то с вами делится.

Любое приложение Осени начинается с точки входа. Создадим файл main.os и другие файлы из нашей диаграммы

Ожидаемая структура:

![alt text](images/image-1.png)

main.os
```bsl  
#Использовать "./src/core"
#Использовать "./src/controller"
#Использовать autumn

Поделка = Новый Поделка();
Поделка.ЗапуститьПриложение();
```

Тут мы сразу подключаем папки /src/controller и /src/core к нашему приложению, а так же фреймворк Осень, который впоследстии сильно упростит разработку.
Но что произайдет в момент ЗапуститьПриложение() ?
Как сделать, что бы наш бот заработал? Мы должны создать класс у которого будет аннотация &Рогатка и наличие метода ПриЗапускеПриложения(), давайте добавим такой к нашему проекту
![alt text](images/image-3.png)

Запускатор.os
```bsl  

#Область ОбъявлениеПеременных

&Пластилин("ТелеграммБот") 
Перем ТелеграммБот; // Класс для запуска телеграм бота

#КонецОбласти

#Область ПубличныйИнтерфейс

&Рогатка
Процедура ПриСозданииОбъекта()
КонецПроцедуры

Процедура ПриЗапускеПриложения() Экспорт

	КоличествоПопытокЗапуска = 10;
	Для Счетчик = 1 По КоличествоПопытокЗапуска Цикл
		
		Попытка
			Сообщить("Старт");
			ТелеграммБот.Запустить();
		Исключение
			Сообщить(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;	
	КонецЦикла;
	Сообщить("Не удалось запустить бот");

КонецПроцедуры

#КонецОбласти

```
Чуть разберем код выше. У нас есть класс который реализует логику общения с телеграмм, мы его назвали ТелеграммБот, что бы начать
работать с этим классом у нас есть 2 пути
1) Создать экземпляр в коде:
Сообщить("Старт");
ТелеграммБот = Новый ТелеграммБот;
ТелеграммБот.Запустить()

2) Внедрить через магию Осень, при чем внедрять можно 3 разными способами
Через свойства, как в варианте выше:
&Пластилин("ТелеграммБот") 
Перем ТелеграммБот; // Класс для запуска телеграм бота

Через специальный метод сеттер

Перем ТелеграммБот;
&Пластилин
Процедура УстановитьТелеграммБот(Значение) Экспорт
    Пароль = Значение;
КонецПроцедуры
или через [конструктор](https://autumn-library.github.io/framework-elements/components-binding)

Когда это можем быть удобно? 
Напримем у нашего класса ТелеграммБот есть поле Токен. и разные методы ОтправитьСообщение(), ОтправитьКартинку() И тд.
В одном месте мы заполнили токен потом в любых других местах "пластилином" мы достаем этот класс, а он уже настроен так как нам нужно, то есть у него уже заполнено поле токен.



Нам нужно как то взаимодействовать с ботом, варианов два, или писать самому или использовать существующие библиотеки.
Хороший программист, ленивый программист, давайте использовать готовую библиотеку












Давайте разберем, о чем эта статья и какие цели я преследую.
ы
### Мои цели

**Личная мотивация**

Я хотел выйти за пределы привычной 1С, попробовать что-то новое, но с минимальным порогом входа. Выбор пал на OneScript и фреймворк Осень. После Никиты узнал, что многие концепции заимствованы из Java — это стало отличным поводом изучить новые подходы, оставаясь в знакомой среде (без необходимости знать английский :) ).

**Помощь сообществу**

В процессе изучения столкнулся с тем, что материалов по Осени не так много. Решил, что мой опыт может помочь другим, кто так же хочет разобраться, но сталкивается с трудностями.

Именно поэтому решил, что статья будет в формате "Мастер-класс" — на примерах значительно проще разбираться во всех концепциях.

Перед тем как проходить мастер класс, я предлагаю в начале прочесть статью оригинал и все статьи по ссылкам. 

## Выбор проекта

Я не хотел повторять приложение, а хотел что то свое, сложнее всего было определиться с идеей. 

Я работаю в франчайзи, и коллеги часто присылают обработки, расширения и т.д. Просматривать их с телефона неудобно, а оперативно проверять код — иногда необходимо. Это и породило идею создать механизм, с помощью которого я смогу быстро глянуть исходники и прокомментировать код.

**Решение:** Создать Telegram-бота, в который кидаем бинарники, а он их преобразует в читаемый код.

## Проблемы, о которых предлагаю подумать

### Проблема №1: Как удобно просматривать код?

**Вариант 1:** Отправлять сырой текст в Telegram.
**Минусы:** нечитаемо, ограничение на 3000 символов.

**Вариант 2:** Использовать Paste1C. Замечательный сервис Paste 1C, где изначально я все и реализовал.
**Минусы:** Что делать, когда у обработки несколько форм и модуль объекта, кидать много ссылок? Это не всегда удобно, особенно когда файлов много.

**Вариант 3:** Файлообменники.
**Минусы:** неудобно для быстрого просмотра.

**Вариант 4:** Gist GitHub.
Почему этот вариант мне понравился?
- Позволяет сравнивать правки между версиями.
- Есть доступ по ссылке (аналог Google Docs). Код виден только тем, кому вы дали ссылку.
**Минусы:** Тоже есть ограничения, вроде 100 файлов.

**Вариант 5:** Репозиторий.
**Минусы:** Нет возможности создавать доступ по ссылке, или всем видно, или приватно с добавлением доступов.

**Итог:** Я выбрал вариант 4, но надо сделать так, чтобы легко можно было расширить возможности и публиковать еще куда-то.

### Проблема №2: Архитектура приложения

Как мы все знаем, лучший код писался во времена УТ 10 с километровыми методами которые делали сразу все. Но мы назло всем так делать не будем. Паттернов и подходов к разработке приложений много, но давайте возьмем за основу **MVC**.

Попробуем разделить наше приложение на слои, чтобы они были независимы.

**Что такое MVC:**
- **V (View)** — так как у нас Telegram-бот, то за вид пусть он и отвечает.
- **C (Controller)** — это наш мостик между отображением и бизнес-логикой.
- **M (Model)** — тут работа с БД и бизнес-логика.


## Шаг 1: Наше первое простое решение


### Создание структуры проекта

Создадим основную структуру проекта:

```
share_bsl/
├── main.os
├── oscript.cfg
├── src/
│   ├── controller/
│   │   └── Классы/
│   ├── core/
│   │   └── Классы/
│   └── data/
│       └── Классы/
└── tests/
```

## Шаг 2: Создание основного приложения

Начнем с главного файла приложения:

```bsl
// main.os
#Использовать "./src/core"
#Использовать "./src/controller"
#Использовать "./src/data"
#Использовать autumn
#использовать autumn-annotation-types
#Использовать autumn-logos
#Использовать autumn-async
#Использовать autumn-data

Совет = Новый СоветДругогоМастера();
Совет.ПрефиксПеременныхСреды("SHAREBOT");

Поделка = Новый Поделка(Совет);
Поделка.ЗапуститьПриложение();
```

## Шаг 3: Создание Telegram-бота

### Установка библиотеки OPI

Как говорится, «хороший программист — ленивый программист», поэтому начал с поиска готовых библиотек. Нашел **OPI** — это значительно упростило работу.

### Создание класса Telegram-бота

```bsl
// src/controller/Классы/ТелеграммБот.os
#Использовать oint 

&Деталька("TELEGRAMM.TOKEN")
Перем Токен;

&Пластилин("Команда", Тип = "Массив")
Перем Команды;

&ЛогПубликация
Перем Лог;

&Число
Перем Смещение;

&Желудь
Процедура ПриСозданииОбъекта()
КонецПроцедуры

Процедура Запустить() Экспорт
    Лог.Отладка("Запущен");

    Пока Истина Цикл
        Ответ = OPI_Telegram.ПолучитьОбновления(Токен, 30, Смещение);
        Результат = Ответ["result"];
        
        Если Результат = Неопределено ИЛИ Результат.ВГраница() = -1 Тогда
            Продолжить;
        Иначе
            Сообщение = Результат[Результат.ВГраница()];
            Смещение = Сообщение["update_id"] + 1;
        КонецЕсли;

        Для Каждого Команда Из Команды Цикл
            Если Команда.ПодходитПоУсловию(Сообщение) Тогда
                Команда.Обработать(Сообщение); 
                Прервать;
            КонецЕсли;
        КонецЦикла;
    КонецЦикла;
КонецПроцедуры
```

## Шаг 4: Создание системы команд

### Первый наивный подход — «лесенка» из условий

```bsl
Если ТипСообщения = "Сообщение" Тогда  
    // Логика...  
ИначеЕсли ТипСообщения = "Файл" Тогда  
    // Логика...  
Иначе  
    // ...  
КонецЕсли;
```

Но такой код сложно поддерживать. Решение нашлось в документации Осени — паттерн **Команда**.

### Создание интерфейса команды

```bsl
// src/controller/Классы/ИнтерфейсКоманда.os
&Интерфейс
Интерфейс ИнтерфейсКоманда

    Функция ПодходитПоУсловию(Сообщение) Экспорт
    КонецФункции

    Процедура Обработать(Сообщение) Экспорт
    КонецПроцедуры

КонецИнтерфейса
```

### Реализация команды для обработки файлов

```bsl
// src/controller/Классы/КомандаФайл.os
#Использовать "./src/controller/Классы/ИнтерфейсКоманда"
#Использовать "./src/core"

&Реализует ИнтерфейсКоманда
Класс КомандаФайл

    &Пластилин("Декомпилятор")
    Перем Декомпилятор;
    
    &Пластилин("Публикатор")
    Перем Публикатор;
    
    &ЛогПубликация
    Перем Лог;

    Функция ПодходитПоУсловию(Сообщение) Экспорт
        Возврат Сообщение["message"]["document"] <> Неопределено;
    КонецФункции

    Процедура Обработать(Сообщение) Экспорт
        Лог.Информация("Получен файл: " + Сообщение["message"]["document"]["file_name"]);
        
        // Логика обработки файла
        // 1. Скачать файл
        // 2. Декомпилировать
        // 3. Опубликовать
        // 4. Отправить ссылку
    КонецПроцедуры

КонецКласса
```

## Шаг 5: Создание декомпилятора

### Использование паттерна Табакерка

Для гибкости в выборе способа декомпиляции используем паттерн **Табакерка** (Factory):

```bsl
// src/core/Классы/Декомпилятор.os
#Использовать 1commands

&Деталька("UNPACK")
Перем СпособРазбора; // Метод: разбирать через exe или через python, варианты exe, py

&ЛогПубликация
Перем Лог;

&Табакерка 
&Пластилин
Перем КомандаЗапускаДекомпилятора;

&Желудь
Процедура ПриСозданииОбъекта()
КонецПроцедуры

Процедура РазобратьФайл(ПутьКФайлу, ПапкаРазбора) Экспорт
    Параметры = Новый Массив;
    Параметры.Добавить(ПутьКФайлу);    
    Параметры.Добавить(ПапкаРазбора);

    КомандаЗапуска = КомандаЗапускаДекомпилятора.Достать(Параметры);
    
    КодВозврата = КомандаЗапуска.Исполнить();
    Лог.Отладка(КомандаЗапуска.ПолучитьВывод());    
    Лог.Отладка(КодВозврата);
КонецПроцедуры
```

## Шаг 6: Создание системы публикации

### Интерфейс публикатора

```bsl
// src/core/Классы/ИнтерфейсПубликатор.os
&Интерфейс
Интерфейс ИнтерфейсПубликатор

    Функция Опубликовать(ПапкаСФайлами, ИмяФайла) Экспорт
    КонецФункции

КонецИнтерфейса
```

### Реализация публикатора для GitHub Gist

```bsl
// src/core/Классы/ПубликаторGist.os
#Использовать "./src/core/Классы/ИнтерфейсПубликатор"

&Реализует ИнтерфейсПубликатор
&Деталька("GITHUB.TOKEN")
Перем Токен;

Класс ПубликаторGist

    Функция Опубликовать(ПапкаСФайлами, ИмяФайла) Экспорт
        // Логика публикации в GitHub Gist
        // 1. Собрать все файлы из папки
        // 2. Создать Gist через GitHub API
        // 3. Вернуть ссылку
    КонецФункции

КонецКласса
```

## Шаг 7: Добавление истории публикаций

### Использование Autumn-Data

Нам нужно обновлять существующие файлы, если они уже были отправлены. Для этого используем **Autumn-Data** — ORM для OneScript:

```bsl
// src/data/Классы/ИсторияПубликаций.os
#Использовать autumn-data

&Сущность
Класс ИсторияПубликаций

    &Колонка
    &ПервичныйКлюч
    Перем Идентификатор;
    
    &Колонка
    Перем ИмяФайла;
    
    &Колонка
    Перем СсылкаНаПубликацию;
    
    &Колонка
    Перем ДатаПубликации;

КонецКласса
```

## Шаг 8: Добавление интерактивной клавиатуры

### Команда для обработки нажатий на клавиатуру

```bsl
// src/controller/Классы/КомандаКлавиатура.os
#Использовать "./src/controller/Классы/ИнтерфейсКоманда"

&Реализует ИнтерфейсКоманда
Класс КомандаКлавиатура

    Функция ПодходитПоУсловию(Сообщение) Экспорт
        Возврат Сообщение["callback_query"] <> Неопределено;
    КонецФункции

    Процедура Обработать(Сообщение) Экспорт
        // Обработка нажатий на кнопки
        // "Обновить файл" или "Загрузить новый"
    КонецПроцедуры

КонецКласса
```

## Шаг 9: Валидация интерфейсов

### Создание валидатора

Для проверки, что все команды реализуют нужный интерфейс:

```bsl
// src/controller/Классы/ВалидаторИнтерфейсов.os
#Использовать autumn-reflection

Класс ВалидаторИнтерфейсов

    Процедура ПроверитьКоманды(Команды) Экспорт
        Для Каждого Команда Из Команды Цикл
            Если НЕ РеализуетИнтерфейс(Команда, "ИнтерфейсКоманда") Тогда
                ВызватьИсключение "Команда " + ТипЗнч(Команда) + " не реализует ИнтерфейсКоманда";
            КонецЕсли;
        КонецЦикла;
    КонецПроцедуры

КонецКласса
```

## Шаг 10: Добавление логирования

### Использование Autumn-Logos

Вместо того чтобы везде писать `Сообщить()`, используем библиотеку **Autumn-Logos**:

```bsl
&ЛогПубликация
Перем Лог;

// В коде используем:
Лог.Отладка("Отладочная информация");
Лог.Информация("Информационное сообщение");
Лог.Предупреждение("Предупреждение");
Лог.Ошибка("Ошибка");
```

Преимущество в том, что мы можем менять уровень вывода сообщений через конфигурацию.

## Шаг 11: Поддержка разных способов декомпиляции

### Создание команд для разных декомпиляторов

```bsl
// Команда для v8unpack.exe
Класс КомандаV8UnpackExe
    // Реализация для .exe файла
КонецКласса

// Команда для Python скрипта
Класс КомандаV8UnpackPy
    // Реализация для Python скрипта
КонецКласса
```

## Шаг 12: Тестирование

### Создание unit-тестов

```bsl
// tests/maintest.os
#Использовать autumn-test

Класс ТестДекомпилятора

    Процедура ТестРазбораФайла()
        // Тест декомпиляции
    КонецПроцедуры

КонецКласса
```

## Шаг 13: Docker-контейнеризация

### Создание Dockerfile

```dockerfile
# docker/Dockerfile
FROM oscript/one:latest

WORKDIR /app
COPY . .

RUN oscript -compile main.os

CMD ["oscript", "main.os"]
```

## Заключение

В этом мастер-классе мы создали полноценное приложение, используя современные подходы к разработке:

1. **MVC архитектура** — разделение на слои
2. **Паттерн Команда** — для обработки разных типов сообщений
3. **Паттерн Табакерка** — для гибкого выбора декомпилятора
4. **Интерфейсы** — для валидации и расширяемости
5. **ORM** — для работы с данными
6. **Логирование** — для отладки
7. **Тестирование** — для качества кода
8. **Контейнеризация** — для развертывания

Этот подход позволяет легко расширять функциональность и поддерживать код в долгосрочной перспективе.

## Что дальше?

В следующих частях мы можем рассмотреть:
- Развертывание в продакшн
- Мониторинг и метрики
- CI/CD пайплайны
- Оптимизация производительности

---

*Надеюсь, этот мастер-класс поможет вам освоить OneScript и фреймворк Осень!*
