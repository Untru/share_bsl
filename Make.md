# Мастер-класс: Создание Telegram-бота для декомпиляции 1С файлов на OneScript и Осень

## Содержание

## Упоминание функционала Осени

Желудь 
Приемка
Пластилин
Свои аннотации
Типизация переменных


## Введение

Приветствую всех! Меня зовут Чегодаев Павел, и я хочу вместе с вами пройти мастер-класс по разработке бота на OneScript и фреймворка Осень.
На написание этой статьи меня вдохновила публикация [Мастер-класс по созданию приложения](https://infostart.ru/1c/articles/2275659/). Поскольку вторая часть пока не вышла, я возьму на себя смелость продолжить начинания Владимира. 

## Почему Осень?
Есть желание расширять кругозор после 15 лет работы с 1С. В Осени многие концепции заимствованы из [Java](https://infostart.ru/1c/articles/1980026/) — это стало отличным поводом изучить новые подходы, оставаясь в знакомой среде языка 1С.

Поскольку статья про мониторинг возможно когда-нибудь выйдет, я предлагаю взять другую тему.

## Техническое задание

Создать Telegram-бота, который на вход принимает бинарные файлы, а на выходе возвращает исходный код.
Приложение должно быть развертываемо в контейнере Docker.

Чтение кода должно быть реализовано максимально удобно.

## Архитектура
Любая разработка начинается с архитектуры решения. Давайте определим основную функциональность, которая должна быть реализована:

+ Обработка сообщений в боте
+ Разбор файлов на исходники
+ Публикация исходников

Попробуйте самостоятельно нарисовать диаграмму классов, а затем мы сравним результаты.

Как мы все знаем, в прошлом писался код с километровыми методами, которые выполняли множество задач одновременно. Мы не будем следовать такому подходу. Паттернов и подходов к разработке приложений много, но давайте возьмем за основу **MVC**.

Попробуем разделить наше приложение на слои, чтобы они были независимы.

**Что такое MVC:**
- **V (View)** — так как у нас Telegram-бот, то за представление пусть он и отвечает.
- **C (Controller)** — это наш мостик между представлением и бизнес-логикой.
- **M (Model)** — здесь работа с БД и бизнес-логика.

У меня получилось так:

![alt text](https://img.plantuml.biz/plantuml/svg/bLBBIiD05DtFLynI5_q15r9mxKU4DhXmsaWILree5GH1A4ANfG_n0nersZOn_OLp_yWpqsAZD10Nmp3tddlEkVTECugzCBxk6DKoNXJfiw0RXu4nVhWBd0TjtwWhhtNfNVYbjBvHMcyXU48X0pmZHSRp9dqia2DNLGbzeZ7bey0hKjvB6SWZvdmNIEI1q2_6XaV7gaUH7t5dfQmxTiWKx_XmF5EvGqAf9TPOo3tlrHuy8d1DWHmR9Z8PqbaX_JtWT_KssQlkeT6uFQrdeGveHrTbyXyKXzgeuhMBcB6VJpju6x0LNCKBOojaNC0XEbirmQQKi8jqbRQYZbN7aBXP9cw-VtLLq--sxRVy1W00
)

Для удобства я буду диаграммы также оставлять в исходном виде

```plantuml
@startuml
class Controller
class Model
package Controller {
  class БотТелеграмм
БотТелеграмм : ПроверитьСообщения()
}
  
package Model {
  class МенеджерПубликаций
  class Декомпилятор
  class Публикатор
}
БотТелеграмм --|> МенеджерПубликаций
МенеджерПубликаций --|> Декомпилятор
МенеджерПубликаций --|> Публикатор
Декомпилятор : РазобратьФайл()
Публикатор : Опубликовать()
МенеджерПубликаций : ОбработатьФайл()

@enduml
```

Давайте создадим структуру проекта. Что бы я ни делал, я всегда начинаю с команды git init, это позволит впоследствии версионировать код и, возможно, поделиться им с вами.

Любое приложение на Осени начинается с точки входа. Создадим файл main.os и другие файлы согласно нашей диаграмме.

Ожидаемая структура:

![alt text](images/image-1.png)

```bsl 
// main.os

#Использовать "./src/core"
#Использовать "./src/controller"
#Использовать autumn

Поделка = Новый Поделка();
Поделка.ЗапуститьПриложение();
```

Здесь мы сразу подключаем папки /src/controller и /src/core к нашему приложению, а также фреймворк Осень, который впоследствии значительно упростит разработку.

Но что произойдет в момент вызова ЗапуститьПриложение()?

Как сделать, чтобы наш бот заработал? Мы должны создать класс, у которого будет аннотация &Рогатка и метод ПриЗапускеПриложения(), давайте добавим такой класс к нашему проекту.

![alt text](images/image-3.png)

```bsl 
// src\core\Классы\Запускатор.os

#Область ОбъявлениеПеременных

&Пластилин("ТелеграммБот") 
Перем ТелеграммБот; // Класс для запуска Telegram-бота

#КонецОбласти

#Область ПубличныйИнтерфейс

&Рогатка
Процедура ПриСозданииОбъекта()
КонецПроцедуры

Процедура ПриЗапускеПриложения() Экспорт

	КоличествоПопытокЗапуска = 10;
	Для Счетчик = 1 По КоличествоПопытокЗапуска Цикл
		
		Попытка
			Сообщить("Старт");
			ТелеграммБот.Запустить();
		Исключение
			Сообщить(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;	
	КонецЦикла;
	Сообщить("Не удалось запустить бот");

КонецПроцедуры

#КонецОбласти
```

Теперь разберем код выше. У нас есть класс, который реализует логику общения с Telegram, мы его назвали ТелеграммБот. Чтобы начать работать с этим классом, у нас есть 2 пути:

1) Создать экземпляр в коде:
```bsl
ТелеграммБот = Новый ТелеграммБот;
ТелеграммБот.Запустить()
```

2) Внедрить через механизм внедрения зависимостей Осени, причем внедрять можно 3 разными способами:

Через свойства, как в варианте выше:
```bsl
&Пластилин("ТелеграммБот") 
Перем ТелеграммБот; // Класс для запуска Telegram-бота
```

Через специальный метод сеттер:
```bsl
Перем ТелеграммБот;
&Пластилин
Процедура УстановитьТелеграммБот(Значение) Экспорт
    Пароль = Значение;
КонецПроцедуры
```
или через [конструктор](https://autumn-library.github.io/framework-elements/components-binding)

В каких случаях это может быть полезно?
Например, у нашего класса ТелеграммБот есть поле Токен и разные методы ОтправитьСообщение(), ОтправитьКартинку() и т.д.

В одном месте мы заполняем токен, потом в любых других местах через аннотацию &Пластилин мы получаем экземпляр этого класса, а он уже настроен так, как нам нужно, то есть у него уже заполнено поле токен.


## Добавляем бота

Нам нужно как-то взаимодействовать с ботом, вариантов два: или писать самому, или использовать существующие библиотеки.

Хороший программист стремится использовать готовые решения, давайте использовать готовую библиотеку. Мне нравится библиотека Антона [ОПИ](https://openintegrations.dev/), поражает подход к написанию и развитию этой библиотеки. Внимание ко всем мелочам.

```bsl
// src\controller\Классы\ТелеграммБот.os

#Использовать oint 

#Область ОбъявлениеПеременных

Перем Смещение;

Перем Токен;

#КонецОбласти

#Область ПубличныйИнтерфейс

&Желудь
Процедура ПриСозданииОбъекта()
	
КонецПроцедуры

Процедура Запустить() Экспорт

	Сообщить("Запущен");
	Токен = "7967956539";

	Пока Истина Цикл
		
		Ответ = OPI_Telegram.ПолучитьОбновления(Токен, 30, Смещение);
		Результат = Ответ["result"];
		
		Если Результат = Неопределено ИЛИ Результат.ВГраница() = -1 Тогда
			Продолжить;
		Иначе
			Сообщение = Результат[Результат.ВГраница()];
			Смещение = Сообщение["update_id"] + 1;
		КонецЕсли;

		ОбработатьСообщение(Сообщение);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ОбработатьСообщение(Сообщение)

	ЧатИД = Сообщение["message"]["chat"]["id"];

	OPI_Telegram.ОтправитьТекстовоеСообщение(Токен, ЧатИД, Сообщение["message"]["text"]);	
КонецПроцедуры

#КонецОбласти
```

Теперь разберем, что тут написано?
 
Мы подключили oint (ОПИ), чтобы использовать уже готовые интеграции с Telegram.
А еще мы подошли к тому что бы обсудить более детально Осень
У метода ПриСозданииОбъекта() установили аннотацию &Желудь, так мы указали, что этот класс мы можем получить в любой момент из Контейнера, создаваемого Осенью, например, как мы сделали в классе Запускатор.

Когда мы пишем &Пластилин - мы получаем экземпляр нашего объекта.
Как можно более простым языком это описать? Если ОЧЕНЬ грубо, то, давайте представим, что у нас есть глобальный контетекст и есть глобальная переменная Соответствие
Ключ - Имя класса, Значение - сам объект, в любом месте мы можешь получить его и использовать.


## Предварительные итоги

На этом этапе у нас с вами готова основа, наш бот даже сейчас будет отвечать эхом. Можно запустить отладку. Для удобства пропишем в отладку запускаемый файл, тогда независимо от позиционированного в проекте файла, все равно запустится нужный.

![alt text](images/image-5.png)

Проверяем наш бот, работает! УРА!

![alt text](images/image-4.png)


## Работаем с секретами

Внимательный читатель наверняка заметил, что очень нехорошо писать токен в коде, особенно когда потом проект идет в публичный репозиторий GitHub. Существуют даже роботы, которые сканируют GitHub на предмет различных секретов.
Мы могли бы создать конфигурационный файл с настройками, запрограммировать его чтение, но Осень все сделала за нас.

Нам всего-то нужно создать файлик autumn-properties.json и указать все секреты там. Не забывайте указывать его в .gitignore, иначе секреты в итоге все равно попадут в публичный доступ.

Попробуем создать конфигурационный файл:

Добавили autumn-properties.json


![alt text](images/image-7.png)
```json
{
    "TELEGRAMM": {
        "TOKEN": "7967956539:"
  
    }
}
```

Теперь чтобы получить доступ к нашей "Настройке" - нам нужно воспользоваться аннотацией &Деталька
![alt text](images/image-6.png)

## Добавляем логирование

Как и в первой части, нам пора позаботиться о логировании нашего приложения. Вместо того чтобы везде писать `Сообщить()`, давайте используем более продвинутую систему логирования.

### Создание класса ЛогАннотация

Во первых добавим библиотеку работы с логами #Использовать autumn-logos, проситать подробнее можно [тут](https://github.com/autumn-library/autumn-logos)

```bsl
// main.os

#Использовать "./src/core"
#Использовать "./src/controller"
#Использовать autumn
#Использовать autumn-logos //Добавили библиотеку рабты с логами
```

Для удобства работы с логами создадим специальный класс `ЛогАннотация.os` в папке `src/core/Классы/`. Благодаря функциональности [Собственные аннотации](https://autumn-library.github.io/framework-elements/custom-annotations) мы можем такою создать. 

```bsl
// src/core/Классы/ЛогАннотация.os

&Аннотация("ЛогПубликация")
&Лог("oscript.lib.share_bsl")
Процедура ПриСозданииОбъекта()

КонецПроцедуры
```

Попробуем переписать класс Запускатор с учетом логов. 

```bsl
// src\core\Классы\Запускатор.os

#Область ОбъявлениеПеременных

&Пластилин("ТелеграммБот") 
Перем ТелеграммБот; // Класс для запуска телеграм бота

&ЛогПубликация
Перем Лог;

#КонецОбласти

#Область ПубличныйИнтерфейс

&Рогатка
Процедура ПриСозданииОбъекта()
КонецПроцедуры

Процедура ПриЗапускеПриложения() Экспорт

	КоличествоПопытокЗапуска = 10;
	Для Счетчик = 1 По КоличествоПопытокЗапуска Цикл
		
		Попытка
			Лог.Информация("Старт");
			ТелеграммБот.Запустить();
		Исключение
			Лог.Ошибка(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;	
	КонецЦикла;
	Лог.Ошибка("Не удалось запустить бот");

КонецПроцедуры

#КонецОбласти
```

Визуально разницу можно увидеть по [коммиту](https://github.com/Untru/share-bsl-step/commit/15b6703c3917e454ed7a11f01942c9cc64d62e97)

![alt text](images/image-8.png)

## Работа с интерфейсом

Пора начинать делать то, ради чего все и затевалось, разбор исходников. Мы предполагаем что пользователь может прислать в бот или сообщение или файл.
Думаю стоит начать с обработки того, что он пришлет. Если пришлет сообщение, скажем, что работаем только с файлами. Если файл то пойдем и разберем его.

Но как это написать? На ум первое что приходит, это доработать класс ТелеграммБот, что бы у нас получилось что то типа:

Идея следующая, мы получаем от бота "Сообщение", проверяем по условиям, какая команда нам подходит, та команда которая подошла занимается обработкой сообщения, и или отправляет в Менеджер публикаций или например сообщает "В данный момент обработка текстовых сообщений не поддерживается."

Попробуйте написать это сами, а потом сравним)

```bsl
Если ЭтоСообщение(Сообщение) Тогда
	//Сообщить чтомы работаем только с файлами
ИначеЕсли ЭтоФайл(Сообщение)
	//Разобрать и вернуть исходники
КонецЕсли;
```
Но я предлагаю пойти по другому пути, вдруг мы будем развивать наше решение и у нас будет больше вариаций работы с сообщениями писать все одном классе не удобно. Возмем паттерн "Команда" и попробуем его применить.

```plantuml
@startuml
class Controller
class Model
package Controller {
  class БотТелеграмм
  class Команда1_Сообщение
  class Команда2_Файл
  class ВалидаторИнтерфейсов
  interface ИнтерфейсКоманда
БотТелеграмм : ПроверитьСообщения()
}
  
package Model {
  class МенеджерПубликаций
  class Декомпилятор
  class Публикатор

}

Команда2_Файл ..|> ИнтерфейсКоманда
Команда1_Сообщение ..|> ИнтерфейсКоманда
ИнтерфейсКоманда : ПодходитПоУсловию(Сообщение)
ИнтерфейсКоманда : Обработать(Сообщение)
БотТелеграмм --|> Команда1_Сообщение
БотТелеграмм --|> Команда2_Файл
Команда2_Файл --|> МенеджерПубликаций
МенеджерПубликаций --|> Декомпилятор
МенеджерПубликаций --|> Публикатор
Декомпилятор : РазобратьФайл()
Публикатор : Опубликовать()
МенеджерПубликаций : ОбработатьФайл()
```

![Изменение модели](https://img.plantuml.biz/plantuml/svg/bLFBIiD05Dq7yW-pR1SjwDA52AxzXX9g536saiQL2hK-G12Bua94hAyFIBNHfcdJNxZpHvwPj3ZL39qkaipCFVVSkUVSh3K2nmyEzZpRgdfEey7MwxN0htkUwqzFDkgRBiBxJdNNsNOL03kqBSOo4DrGoblqIX4bU3vvaq8Qqb11F52Aav16rADmgK8lsAVKvPV0ZwXFaGwxNA5th6DA5CGjJX9a8OwwAUhTqmYhY3Vv6HXZVWAE3v6nKmjSVykfkYm7CrF9jdHzi1L67Mn0ATAfprlywcyBl5qesjQngFchbvHlHgf7YOvGy4joTVWfTMKp0pHpWM-ieE-07CXBZX59U3jhLq7Cva-YyXxeHwCaAvUFLatqcEkQCTCSX5GO1pr-Bjv2ORb_0p2HklVvTU5__Q8PzHDoX9TTwMyexDEGwIQWL19z6apn8WpgR6kzolACniO4DU7J3jO27BcZfsCMDZoZfMyfM3CpOTga-7Fow3Blnaf0Z4BcNz7mhldsgvL_0000)


Новые команды:

```bsl
// src\controller\Классы\КомандаСообщение.os

#Использовать oint

#Область ОбъявлениеПеременных

&Деталька("TELEGRAMM.TOKEN")
Перем Токен;

#КонецОбласти

#Область ПрограммныйИнтерфейс

&Желудь
&Прозвище("Команда")
&Реализует("ИнтерфейсКоманда")
Процедура ПриСозданииОбъекта()
	
КонецПроцедуры

Функция ПодходитПоУсловию(Сообщение) Экспорт
	
	Подходит = Сообщение.Получить("message") <> Неопределено И Сообщение["message"].Получить("document") = Неопределено;
	Возврат Подходит;
	
КонецФункции

&Асинх
Процедура Обработать(Сообщение) Экспорт

	ЧатИД = Сообщение["message"]["chat"]["id"];
	OPI_Telegram.ОтправитьТекстовоеСообщение(Токен, ЧатИД, 
		"В данный момент обработка текстовых сообщений не поддерживается.");

КонецПроцедуры

#КонецОбласти
```

```bsl
// src\controller\Классы\КомандаФайл.os

#Использовать oint

#Область ОбъявлениеПеременных

&Деталька("TELEGRAMM.TOKEN")
Перем Токен;

&Деталька("FILEMAXSIZE")
Перем МаксимальныйРазмерФайла;

&Пластилин
Перем МенеджерПубликаций;

&ЛогПубликация
Перем Лог;

#КонецОбласти

#Область ПрограммныйИнтерфейс

&Желудь
&Прозвище("Команда")
&Реализует("ИнтерфейсКоманда")
Процедура ПриСозданииОбъекта()
	
КонецПроцедуры

Функция ПодходитПоУсловию(Сообщение) Экспорт
	
	Подходит = Сообщение.Получить("message") <> Неопределено И Сообщение["message"].Получить("document") <> Неопределено;
	Возврат Подходит;
	
КонецФункции

Процедура Обработать(Сообщение) Экспорт
	
	ЧатИД = Сообщение["message"]["chat"]["id"];
	ИДПользователя = Сообщение["message"]["from"]["id"];
	ИмяФайла = Сообщение["message"]["document"]["file_name"];
	ИДФайла = Сообщение["message"]["document"]["file_id"];

	Попытка
		ФайлВалидный(Сообщение);
	Исключение
		Информация = ИнформацияОбОшибке();
		OPI_Telegram.ОтправитьТекстовоеСообщение(Токен, ЧатИД, Информация.Описание);
		Возврат;
	КонецПопытки;

	ДвоичныеДанные = OPI_Telegram.СкачатьФайл(Токен, ИДФайла);	
	НомерСообщения = Сообщение["update_id"];

	ДанныеДляРазбораФайла = МенеджерПубликаций.НовыйДанныеДляРазбораФайла();	
	ДанныеДляРазбораФайла.ИДПользователя = ИДПользователя;
	ДанныеДляРазбораФайла.ИмяФайла = ИмяФайла;
	ДанныеДляРазбораФайла.НомерСеанса = НомерСообщения;	
	ДанныеДляРазбораФайла.ДвоичныеДанные = ДвоичныеДанные;	
	ДанныеДляРазбораФайла.ИДФайла = ИДФайла;
	ДанныеДляРазбораФайла.Обновление = Ложь;

	ТекстОтвета = МенеджерПубликаций.ОбработатьФайл(ДанныеДляРазбораФайла);
	OPI_Telegram.ОтправитьТекстовоеСообщение(Токен, ЧатИД, ТекстОтвета);
	
	Лог.Отладка(ТекстОтвета);

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ФайлВалидный(Сообщение)
	
	РазмерФайла = Сообщение["message"]["document"]["file_size"];
	ИмяФайла = Сообщение["message"]["document"]["file_name"];
	Если РазмерФайла > МаксимальныйРазмерФайла Тогда
		ВызватьИсключение "Мы пока не принимаем больше файлы";
	КонецЕсли;
		               
	Расширение = СтрРазделить(ИмяФайла, ".");
	Если НЕ РаботаСМодулями.ДопустимоеРасширение(Расширение[Расширение.ВГраница()]) Тогда
		ВызватьИсключение "Текущее расширение файла не поддерживатеся";
	КонецЕсли;

КонецПроцедуры

#КонецОбласти
```

Добавил общий модуль

```bsl
// src\core\Модули\РаботаСМодулями.os

#Область ПрограмныйИнтерфейс

Функция ДопустимоеРасширение(Расширения) Экспорт
    
    Возврат ВалидныеРасширения().Найти(Расширения) <> Неопределено;
    
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ВалидныеРасширения()
    
    Расширения = Новый Массив;
    Расширения.Добавить("epf");
    Расширения.Добавить("ert");
    Расширения.Добавить("cf");
    Расширения.Добавить("cfe");
    Возврат Расширения;
    
КонецФункции

КонецФункции

#КонецОбласти
```

Теперь поменяем наш ТелеграммБот с учетом команд:

```bsl
// src\controller\Классы\ТелеграммБот.os

#Использовать oint 

#Область ОбъявлениеПеременных

&ЛогПубликация
Перем Лог;

&Деталька("TELEGRAMM.TOKEN")
Перем Токен;

&Пластилин("Команда", Тип = "Массив")
Перем Команды;

&Число
Перем Смещение;

Перем Токен;

#КонецОбласти

#Область ПубличныйИнтерфейс

&Желудь
Процедура ПриСозданииОбъекта()
	
КонецПроцедуры

Процедура Запустить() Экспорт

	Лог.Информация("Запущен");

	Пока Истина Цикл
		
		Ответ = OPI_Telegram.ПолучитьОбновления(Токен, 30, Смещение);
		Результат = Ответ["result"];
		
		Если Результат = Неопределено ИЛИ Результат.ВГраница() = -1 Тогда
			Продолжить;
		Иначе
			Сообщение = Результат[Результат.ВГраница()];
			Смещение = Сообщение["update_id"] + 1;
		КонецЕсли;

		Для Каждого Команда Из Команды Цикл
			Если Команда.ПодходитПоУсловию(Сообщение) Тогда
				Команда.Обработать(Сообщение); 
				Прервать;
			КонецЕсли;
		КонецЦикла;

	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти
```

Тут есть что обсудить.
Во первых, так как я планирую в будующем использовать больше команд, я заложил под это основу.
![Команды](images/image-9.png)

Командам я дал прозвище, [алиасы](https://autumn-library.github.io/framework-elements/aliases-grouping), теперь я могу обращаться сразу ко всем Желудям с одинаковым прозвещем, например обходить в цикле. Если бы не эта возможность, мне пришлось бы реализовывать паттерн  [фабрики](https://javarush.com/groups/posts/2370-pattern-proektirovanija-factory) и [стратегии](https://javarush.com/groups/posts/2271-pattern-proektirovanija-strategija), например. Тут же Осень все взяла на себя!

> &Пластилин("Команда", Тип = "Массив")
> Перем Команды;

Для работы с командами я определил единный интерфейс, теперь я хочу что бы он проверялся, ну как во взрослых языках)) 

Для этого есть библиотека extends, я создал класс ВалидаторИнтерфейсов.os 

```bsl
// src\core\Классы\ВалидаторИнтерфейсов.os

#Использовать extends

&Приемка
Процедура ПриСозданииОбъекта()
КонецПроцедуры

Процедура ПриДобавленииОпределенияЖелудя(ОпределениеЖелудя) Экспорт
	
	Если ЕстьИнтерфейс(ОпределениеЖелудя.Прозвища()) Тогда
		ВалидаторРеализации = Новый ВалидаторРеализации();
		ВалидаторРеализации.ИнтерфейсыРеализованыКорректно(ОпределениеЖелудя.ТипЖелудя());
	КонецЕсли;

КонецПроцедуры

Функция ВалидируемыеИнтерфейсы() 
	
	Результат = Новый Массив;
	Результат.Добавить("Команда");
	Возврат Результат;

КонецФункции

Функция ЕстьИнтерфейс(Прозвища) Экспорт
	
	Для каждого ИмяИнтерфейса Из ВалидируемыеИнтерфейсы() Цикл
		Если Прозвища.Найти(ИмяИнтерфейса) <> Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
			
	Возврат Ложь;
	
КонецФункции
```

В нем проверяю интерфейс всех команд которые были добавленны с одинаковым прозищем. Так же заложил возможнотсь расширять валидируемые интрефейсы `ВалидируемыеИнтерфейсы()`, но теперь надло понять моменнт, когда нужно выполнять эту проверку. На помощь приходит аннатация &Приемка

> Специальный тип желудя для обработки определений желудей.
>
> Аналог &Напильника для `ОпределениеЖелудя`. Срабатывает каждый раз, когда в контекст добавляется новое
> определение желудя. При добавлении самой Приемки в контекст, все ранее добавленные определения желудей
> передаются в Приемку для проверки.

Когда в ПриДобавленииОпределенияЖелудя попадает желудь, мы проверяем его прозвище, и если прозвище "Команда", мы проверяем его интерфейс на осответствие специальному классу ИнтерфейсКоманда.os, у которого должна быть аннотация &Интерфейс и требуемые методы, важно, тут так же учитывается количество параметров.

```bsl
// src\controller\Классы\ИнтерфейсКоманда.os

&Интерфейс
Процедура ПриСозданииОбъекта()
КонецПроцедуры

Процедура Обработать(Сообщение) Экспорт
КонецПроцедуры

Функция ПодходитПоУсловию(Сообщение) Экспорт
	Возврат Ложь;
КонецФункции 
```

Если обратили внимание, то наверно заметили как передаются параметры с команды до менеджера публикаций, в менеджере публикаций я определяю ДТО для обмена данными между нашими слоями. (грубо говоря структура) `МенеджерПубликаций.НовыйДанныеДляРазбораФайла();` Я решил передавать на слой логики побольше информации, а не только двоичные данные. Позже, я думаю мне это понадобится.


Так же внимательный читатель увидел аннотацию &Число - это тоже одна из фишек  фреймворка Осени, типизиторать переменные. Для того тчо бы это использовать, нам нужно подключить autumn-annotation-types

```bsl
// main.os

#Использовать "./src/core"
#Использовать "./src/controller"
#Использовать autumn
#Использовать autumn-logos
#использовать autumn-annotation-types

Поделка = Новый Поделка();
Поделка.ЗапуститьПриложение();
```

Текущий вид проекта
![alt text](images/image-10.png)

Так же изменения можно легко отследить по коммитам репозитория, я постарался фиксировать доработки шагами. [Коммиты](https://github.com/Untru/share-bsl-step/commits/master/)

## Разбор бинарников

Мы подошли к теме разбора бинарников, на текущий момент и знаю следующие методы
+ С помощью платформы 1с в пакетном режиме
+ С помощью утилиты ibcmd 
+ С помощью библиотеки v8unpaсk
+ С помощью saby v8unpack - консольная утилита для сборки и распаковки.

Мой выбор пал на последний вариант, пакетник работает долго,  с ibcmd у меня свои счеты, а библиотека v8unpaсk раскрывает исходники до уровня, когда все файлы представленны в виде идентификаторов

Для того, что бы мне разбирать файлы, я создал 2 папки, куда буду класть исходники и куда все буду распаковывать, что бы папки были в реапозитории даже кодга они пустые, я поместил в них пустой файл .gitkeep

![alt text](images/image-11.png)

Давайте подумаем, с какими сложностями мы можем столкнуться?

Верно, что будет если с ботом будут общаться параллельно, а файлы будут одинаково называться? Что бы их разделить я решил использовать номер сообщения как "идентификатор" сеанса

```bsl
src\core\Классы\МенеджерПубликаций.os

...

Функция ОбработатьФайл(ДанныеДляРазбораФайла) Экспорт

	Каталог = "unpack/" + ДанныеДляРазбораФайла.НомерСеанса;
	КаталогИсходник = "pack/" + ДанныеДляРазбораФайла.НомерСеанса;
	
	СоздатьКаталог(Каталог);
	СоздатьКаталог(КаталогИсходник);

	ПутьКФайлу = СтрШаблон("%1/%2", КаталогИсходник, ДанныеДляРазбораФайла.ИмяФайла);
	
	Лог.Информация("Записываем файл");
	ДанныеДляРазбораФайла.ДвоичныеДанные.Записать(ПутьКФайлу);
	
	Лог.Информация("Разбираем файл");
	Декомпилятор.РазобратьФайл(ПутьКФайлу, Каталог);
	
	// УдалитьФайлы(Каталог); На время отладки закоментирую этот код
	// УдалитьФайлы(КаталогИсходник);
	
	Возврат ДанныеПубликации.СсылкаНаПубликацию;

КонецФункции

```

Изначально я взял декомпиляториз релизов, в виде exe исполняемого файла, какие это наложит ограничения? Верно! Я не смогу использовать этот функционал в докере, по этому я реализовал 2 варианта, один с помощью exe и нативно может запуститься на windows и  py скрипт требующий установки python.

Добавил настройку в `autumn-properties.json`, на уровне соглашения нужно договорится, что настройка "UNPACK" будем иметь два значения, "py" 
![alt text](images/image-12.png)

```bsl
#Использовать 1commands

#Область ПрограммныйИнтерфейс

&Дуб
Процедура ПриСозданииОбъекта()
КонецПроцедуры

&Завязь(Тип = "Строка")
&Характер("Компанейский")
Функция КомандаЗапускаДекомпилятора(&Деталька(Значение = "UNPACK", ЗначениеПоУмолчанию = "py") 
					КомандаЗапускаДекомпилятора, &Блестяшка ПутьКФайлу, &Блестяшка ПапкаРазбора) Экспорт
	
	Команда = Новый Команда;

	Если КомандаЗапускаДекомпилятора = "py" Тогда
		ИсполняющийСкрипт = ТекущийКаталог() + "/src/v8unpack/v8u.py";
		Команда.УстановитьКоманду("python3");
		Команда.ДобавитьПараметр(ИсполняющийСкрипт);	
	Иначе
		Команда.УстановитьКоманду("src/v8unpack/v8unpack.exe");
		Команда.ДобавитьПараметр("-E");	
	КонецЕсли;

	Команда.ДобавитьПараметр(Команда.ОбернутьВКавычки(ПутьКФайлу));	
	Команда.ДобавитьПараметр(ПапкаРазбора);

	Возврат Команда;

КонецФункции

#КонецОбласти
```

Я решил сделать Компанейский Желудь, что это значит? При полученнии его я буду получать новый экземпляр класса, так как у него по разному буду заполенны свойства пути к файлу. Поля которые будут заполняться по разному в конструкторе я отметил с помощью анатации [&Блестяшка](https://autumn-library.github.io/single-page/autumn#%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B0%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D0%B0), Теперь когда я буду "Доставать" свой желудь, я буду дозаполнять его поля:

```bsl
// src\core\Классы\Декомпилятор.os

#Использовать 1commands

#Область ОбъявлениеПеременных

&Деталька("UNPACK")
Перем СпособРазбора; //Метод, разбирать через exe или через pythot, варианты exe, py

&ЛогПубликация
Перем Лог;

&Табакерка 
&Пластилин
Перем КомандаЗапускаДекомпилятора;

#КонецОбласти

#Область ПрограммныйИнтерфейс

&Желудь
Процедура ПриСозданииОбъекта()
	
КонецПроцедуры

Процедура РазобратьФайл(ПутьКФайлу, ПапкаРазбора) Экспорт
	
	Параметры = Новый Массив;
	Параметры.Добавить(ПутьКФайлу);	
	Параметры.Добавить(ПапкаРазбора);

	КомандаЗапуска = КомандаЗапускаДекомпилятора.Достать(Параметры);
	
	КодВозврата = КомандаЗапуска.Исполнить();
	Лог.Отладка(КомандаЗапуска.ПолучитьВывод());
	Лог.Отладка(КодВозврата);

КонецПроцедуры

#КонецОбласти
```
Давай обратив внимание, что такой желудь надо пометить аннатацией `&Табакерка` А в момент использования и вызываем код  `КомандаЗапускаДекомпилятора.Достать(Параметры);`

Обоснование почему я использовал дуб? TODO

## Публикация файлов

### Как удобно просматривать код на телефоне?

**Вариант 1:** Отправлять сырой текст в Telegram.
**Минусы:** Нечитаемо, ограничение на 3000 символов.

**Вариант 2:** Использовать [Paste1C](https://paste1c.ru/). Замечательный сервис Paste 1C, где изначально я все и реализовал.
**Минусы:** Что делать, когда у обработки несколько форм и модуль объекта, кидать много ссылок? Это не всегда удобно, особенно когда файлов много.

**Вариант 3:** Файлообменники.
**Минусы:** Не удобно для быстрого просмотра.

**Вариант 4:** Gist GitHub.
- Позволяет сравнивать правки между версиями.
- Есть доступ по ссылке (аналог Google Docs). Код виден только тем, кому вы дали ссылку.
**Минусы:** Тоже есть ограничения, вроде 100 файлов.

**Вариант 5:** Репозиторий.
**Минусы:** Нет возможности создавать доступ по ссылке, или всем видно, или приватно с добавлением доступов.

**Итог:** Я выбрал вариант 4, но надо сделать так, чтобы легко можно было расширить возможности и публиковать еще куда-то.

Мы уже знаем как нам работать с разными классами которые объедены одним алиасом
+ Добавляем нужный интерфейс в валидатор


```bsl
Функция ВалидируемыеИнтерфейсы() 
	
	Результат = Новый Массив;
	Результат.Добавить("Команда");
	Результат.Добавить("Публикатор");
	Возврат Результат;

КонецФункции
```
+ Добавляем Описание интерфейса

```bsl
&Интерфейс
Процедура ПриСозданииОбъекта()
КонецПроцедуры

Функция Опубликовать(ТекстыМодулей, ДанныеДляРазбораФайла) Экспорт
	Возврат Ложь;
КонецФункции
```

+ Доваляем классы для публикации

```bsl
// src\core\Классы\ПубликаторGist.os

#Использовать 1connector

#Область ОбъявлениеПеременных

&Деталька("GIST.TOKEN")
Перем Токен;

&Деталька("GIST.NAME")
Перем Имя;

&ЛогПубликация
Перем Лог;

#КонецОбласти

&Желудь
&Прозвище("Публикатор")
&Реализует("ИнтерфейсПубликатор")
Процедура ПриСозданииОбъекта()
	
КонецПроцедуры

Функция Опубликовать(ТекстыМодулей, ДанныеДляРазбораФайла) Экспорт
	
	Ссылки = Новый Соответствие();
	АдресРесурса = АдресРесурса();
	
	Заголовки = Новый Структура();
	Заголовки.Вставить("Authorization", "token " + Токен);
	
	ФайлыДляAPI = Новый Соответствие();
	Для Каждого Файл Из ТекстыМодулей Цикл
		Если НЕ ЗначениеЗаполнено(Файл.Значение) Тогда
			Лог.Отладка("Файл не содержит данных для публикации: " + Файл.Ключ);
			Продолжить;
		КонецЕсли;
		ФайлДанные = Новый Соответствие();
		ФайлДанные.Вставить("content", Файл.Значение);
		ФайлыДляAPI.Вставить(Файл.Ключ, ФайлДанные);
		
	КонецЦикла;
	
	Тело = Новый Соответствие();
	Тело.Вставить("files", ФайлыДляAPI);
	Тело.Вставить("public", Ложь);
	Тело.Вставить("description", "Gist создан из 1С " + ТекущаяДата());
	
	Если ДанныеДляРазбораФайла.Обновление Тогда
		Ответ = КоннекторHTTP.Patch(СтрШаблон("%1/%2", АдресРесурса, ДанныеДляРазбораФайла.ИДПубликации),
				ОбъектВJson(Тело), Новый Структура("Заголовки", Заголовки)
			);
	Иначе
		Ответ = КоннекторHTTP.Post(АдресРесурса, , Тело, Новый Структура("Заголовки", Заголовки));
	КонецЕсли;
	
	Если КодСостоянияУспешный(Ответ.КодСостояния) Тогда
		ОтветJson = Ответ.Json();
	Иначе
		Лог.Ошибка("Не удалось опубликовать файл в Gist: Код состояния" + Ответ.КодСостояния);
		ВызватьИсключение "Не удалось опубликовать файл в Gist: Код состояния" + Ответ.КодСостояния;
	КонецЕсли;
	
	Оглавление = ОглавлениеПоДаннымGist(ОтветJson);
	АдресРесурса = СтрШаблон("%1/%2", АдресРесурса, ОтветJson["id"]);
	
	ФайлДанные = Новый Соответствие();
	ФайлДанные.Вставить("content", Оглавление);
	ФайлыДляAPI.Вставить("Contents.md", ФайлДанные);
	
	Тело = Новый Соответствие();
	Тело.Вставить("files", ФайлыДляAPI);
	Тело.Вставить("public", Ложь);
	Тело.Вставить("description", "Gist создан из 1С " + ТекущаяДата());
	
	Ответ = КоннекторHTTP.Patch(АдресРесурса, ОбъектВJson(Тело), Новый Структура("Заголовки", Заголовки));
	Если КодСостоянияУспешный(Ответ.КодСостояния) Тогда
		ОтветJson = Ответ.Json();
		Ссылки.Вставить(ОтветJson["id"], ОтветJson["html_url"] + "#file-contents-md");
	КонецЕсли;
	
	Возврат Ссылки;
	
КонецФункции

Функция АдресРесурса()
	
	Возврат "https://api.github.com/gists";
	
КонецФункции

Функция ОбъектВJson(Объект)
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Объект);
	
	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции

//Актуально на момент тестов, так как у меня очень много публикаций было создано
Процедура УдалитьВсеПубликации() Экспорт
	
	Заголовки = Новый Структура();
	Заголовки.Вставить("Authorization", "token " + Токен);
	Адрес = СтрШаблон("https://api.github.com/users/%1/gists", Имя);
	Гисты = КоннекторHTTP.Get(Адрес, , Новый Структура("Заголовки", Заголовки)).Json();
	
	Для Каждого Гист Из Гисты Цикл
		Ответ = КоннекторHTTP.delete("https://api.github.com/gists/" + Гист["id"], , ,
				Новый Структура("Заголовки", Заголовки)
			);
	КонецЦикла;
	
КонецПроцедуры

Функция КодСостоянияУспешный(КодСостояния)
	
	КодыОтвета = Новый Массив;
	КодыОтвета.Добавить(200);
	КодыОтвета.Добавить(201);
	
	Возврат КодыОтвета.Найти(КодСостояния) <> Неопределено;
	
КонецФункции

Функция ОглавлениеПоДаннымGist(Данные)
	
	Дерево = РаботаСМодулями.ДеревоОбъектов(Данные);
	
	Результат = "# Дерево файлов
		|
		|";
	
	Для Каждого КлючИЗначение Из Дерево Цикл
		ТипОбъекта = КлючИЗначение.Ключ;
		Объекты = КлючИЗначение.Значение;
		
		ТекстовоеОписаниеОбъектов = Новый Массив;
		Для Каждого КлючИЗначение2 Из Объекты Цикл
			ИмяОбъекта = КлючИЗначение2.Ключ;
			Модули = КлючИЗначение2.Значение;
			СсылкиНаМодули = Новый Массив();
			Для Каждого Модуль Из Модули Цикл
				СсылкиНаМодули.Добавить(СтрШаблон("- [%1](%2)", Модуль.Описание, Модуль.Ссылка));
			КонецЦикла;
			
			ТекстовоеОписаниеОбъектов.Добавить(СтрШаблон("
					| %1
					|%2
					|", ИмяОбъекта, СтрСоединить(СсылкиНаМодули, Символы.ПС)));
			
		КонецЦикла;
		
		Результат = Результат + СтрШаблон("
				|<details>
				| <summary><strong> %1 </strong></summary>
				|%2
				|</details>", ТипОбъекта, СтрСоединить(ТекстовоеОписаниеОбъектов, Символы.ПС));
		
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

```

```bsl
// src\core\Классы\ПубликаторPaste1C.os

#Использовать 1connector

&Деталька("PASTE1C.HEADER")
Перем HEADER;


&Желудь
&Прозвище("Публикатор")
&Реализует("ИнтерфейсПубликатор")
Процедура ПриСозданииОбъекта()
	
КонецПроцедуры

Функция Опубликовать(ТекстыМодулей, ДанныеДляРазбораФайла) Экспорт
	//TODO Продумать удобный способ работы с paste1c, главная проблема в том что 
	//разные модули будут публиковаться по разным ссылкам, что не удобно для анализа
	Ссылки = Новый Массив;

	АдресРесурса = АдресРесурса();
	
	Заголовки = Новый Соответствие();
	Заголовки.Вставить("API-origin", HEADER);
	
	Для Каждого Текст Из ТекстыМодулей Цикл
		
		Тело = НовыйСообщение();
		Тело["Shared"]["title"] = Текст.Ключ;
		Тело["Shared"]["code"] = Текст.Значение;	

		Ответ = КоннекторHTTP.Post(АдресРесурса,, Тело, Новый Структура("Заголовки", Заголовки));
		ОтветJson = Ответ.Json();

		Ссылки.Вставить(ОтветJson["id"], ОтветJson["full_url"]);
	КонецЦикла;
	
	Возврат Ссылки;
	
КонецФункции

Функция НовыйСообщение()

	СоставТела = Новый Соответствие();
	СоставТела.Вставить("title", "");
	СоставТела.Вставить("description", "Код создан из 1С " + ТекущаяДата());
	СоставТела.Вставить("context", "");
	СоставТела.Вставить("code", "");
	СоставТела.Вставить("query_mode", 0);
	
	Тело = Новый Соответствие();
	Тело.Вставить("Shared", СоставТела);

	Возврат Тело;

КонецФункции

Функция АдресРесурса()

	Возврат "https://paste1c.ru/paste";

КонецФункции
```

Не буду подробно останавливаться на коде, только скажу, что я тут использую библиотеку 1connector, что бы упростить написание запросов.

Так же в настройки я добавил свойство `"SHARESERVICE": ["ПубликаторGist", "ПубликаторЕщеКакойНибудь"]`, что бы на их уровне мы могли определять, где будет публиковтаься код. Если что то из листинга не понятно, пишите в комментарии, и  я расширю статью пояснениями.

Так же для GIST я реализовал оглавление для того, что бы проще было орентироваться по файлам.
![alt text](images/image-13.png)


## Подключаем базу данных

У нас с вами почти все готово, файлы отправляются, код присылается, чего еще желать?

Давайте смоделируем такую ситуацию, мне отправляют обработку, я ее смотрю и оставляю свои коментарии, программист правит код, и отправляет обратно, было бы удобно заменять публикацию новой, мало того, возможности Gist нам покажут, какой код был изменен.
Но как это сделать, нам же надо хранить где то информацию и том, какие публикации были уже отправлены. Предлагаю подключить к нашему боту базу данных. И тут тоже Осень готова нам помочь. 

Нарисуем взаимодействие пользователя с телеграмм.
![alt text](images/image-14.png)
+ Будем сохранять публикации, тогда когда в слудующий раз нам нужно будет ее обновить, мы будем знать - какую.
+ Будем сохранять информацию о входящем файле, так как с ним мы будем взаимодействовать уже после того как показали клавиатуру.

Итого, нам нужно 2 таблицы, ИсторияПубликаций и ИсторияФайлов

Подключать библиотеку [autumn-data](https://autumn-library.github.io/autumn-data/). Для этого нам нужно создать описание таблиц, сделаем это в новой папке data.

Внесем настройки для работы с библиотекой в autumn-properties.json

```JSON
    "data": {
        "ИсточникиДанных": {
            "ТипКоннектора": "КоннекторJSON",
            "СтрокаСоединения": "./DataBase"
        }
    },
```


```bsl
// src\data\Классы\ИсторияПубликаций.os

// BSLLS:ExportVariables-off
&Идентификатор
&ГенерируемоеЗначение			// Заполняется автоматически при сохранении сущности
&Колонка(Тип = "Целое")			// Хранит целочисленные значения
Перем Идентификатор Экспорт;	// Имя колонки в базе - `Идентификатор`

&Колонка(Тип = "Целое")
Перем ИДПользователя Экспорт;	// Колонка `ИДПользователя`

&Колонка(Тип = "Строка")
Перем ИмяФайла Экспорт;			// Колонка `ИмяФайла`

&Колонка(Тип = "ДатаВремя")
Перем ДатаОтправки Экспорт;			// Колонка `ДатаОтправки`

&Колонка(Тип = "Строка")
Перем ИДПубликации Экспорт;			// Колонка `ИДПубликации`

&Колонка(Тип = "Строка")
Перем ИДФайла Экспорт;			// Колонка `ИДФайла`

&Сущность(ИмяТаблицы = "ИсторияПубликаций")
Процедура ПриСозданииОбъекта()

КонецПроцедуры
```

```bsl
// rc\data\Классы\ИсторияФайлов.os

// BSLLS:ExportVariables-off
&Идентификатор
&ГенерируемоеЗначение
&Колонка(Тип = "Целое")	
Перем Идентификатор Экспорт;

&Колонка(Тип = "Строка")
Перем ИДФайла Экспорт;

&Колонка(Тип = "Строка")
Перем ИмяФайла Экспорт;

&Сущность(ИмяТаблицы = "ИсторияФайлов")
Процедура ПриСозданииОбъекта()


КонецПроцедуры
```

У меня в vscode подключен bslls и он мне ругается, что тужно описать значение переменных. Мне кажется тут это делать излишним, что бы не ругался, предлагаю отключить в этом файле эту проверку `// BSLLS:ExportVariables-off`. Обратите внимание на аннотации &Идентификатор И &ГенерируемоеЗначение, при записи в таблицу мы автоматически будем генерировть идентификатор.

Теперь мы должны описать логику записи и получения данных из таблиц, покажу на примере таблицы ИсторияПубликаций
```bsl
// src\data\Классы\ХранилищеИсторияПубликаций.os

// BSLLS:UnusedParameters-off
#Область ОбъявлениеПеременных

&Родитель
Перем ХранилищеСущностей;

#КонецОбласти

#Область ПрограмныйИнтерфейс

&ХранилищеСущностей("ИсторияПубликаций")
Процедура ПриСозданииОбъекта()
КонецПроцедуры

&МетодЗапроса
Функция ПолучитьОдноПоИдентификаторРавно(Идентификатор) Экспорт
	Возврат Неопределено;
КонецФункции

&МетодЗапроса
Функция ПолучитьПоИДПользователяРавноИИмяФайлаРавно(ИДПользователя, ИмяФайла) Экспорт
    Возврат Неопределено;
КонецФункции

Функция СохранитьЗаписьОФайле(ДанныеФайла) Экспорт

	ИсторияПубликаций = ХранилищеСущностей.СоздатьЭлемент();
	ИсторияПубликаций.ИДПользователя = ДанныеФайла.ИДПользователя;
	ИсторияПубликаций.ИмяФайла = ДанныеФайла.ИмяФайла;	
	ИсторияПубликаций.ДатаОтправки = ТекущаяДата();	
	ИсторияПубликаций.ИДПубликации = ДанныеФайла.ИДПубликации;	
	ИсторияПубликаций.ИДФайла = ДанныеФайла.ИДФайла;
	
	ИсторияПубликаций.Сохранить();
	
	Возврат ИсторияПубликаций;

КонецФункции

#КонецОбласти
```

К этому классу можно относится, как например мы относимся в 1с к Модулю Менеджера, [&МетодЗапроса](https://autumn-library.github.io/autumn-data/query-methods) это анатация которая позволяет кодогенерировтаь необходимый нам запрос "под капотом". Например `ПолучитьПоИДПользователяРавноИИмяФайлаРавно()` позволяет найти запись по двум полям, и нет необходимости описывать отборы.

## Итоги и домашнее задание

У нас осталось всего несколько шагов до запуска своего бота. 
Надо подготовить packagedef, он поможет нам собрать пакет, в докер контейнере.


```bsl
Описание.Имя("share-bot")
        .Версия("0.0.1")
        .Автор("Чегодаев Павел")
        .АдресАвтора("https://github.com/untru")
        .АдресРепозитория("https://github.com/Untru/share_bsl")
        .Описание("Отправка в телеграмм исходников и их разбор")
        .ВерсияСреды("2.0.0-rc.7")
        .ВключитьФайл("src")
        .ВключитьФайл("main.os")
        .ВключитьФайл("packagedef")
        .ЗависитОт("autumn", "4.3.11" )
        .ЗависитОт("oint")
        .ЗависитОт("1connector")
        .ЗависитОт("autumn-annotation-types")
        .ЗависитОт("autumn-async")
        .ЗависитОт("autumn-data")
         
        .ИсполняемыйФайл("main.os", "share-bot")
        ;
```

Создаем докер файл, который на основании образа onescript:dev развернется, установим python, скопируем файлы относящиеся к проекту и запустим наш бот

```Dockerfile
FROM evilbeaver/onescript:dev
RUN apt-get update
RUN apt-get install -y python3

WORKDIR /app

COPY ./packagedef .

COPY ./src ./src
COPY ./main.os .

RUN opm install opm \
  && opm build . \
  && cp share-bot-*.ospx bot.ospx \
  && opm install -f bot.ospx

CMD ["share-bot"]
```

docker build -t sharebot -f docker/Dockerfile .
docker run sharebot

Проверяем работоспособность. ТУТ ГИФ

Я обещал домашнее задание? Да! Хороший тон, для любого опенсорс проекта - это наличие тестов, давай придумаем тесты для нашего ботаи и обсудим их в коментариях к статье.